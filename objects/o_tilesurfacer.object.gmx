<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///loop through room and find tile of -5 depth and create a collision object.
for (var xx = 0; xx &lt;= room_width; xx += CELLSIZE)
    for (var yy = 0; yy &lt;= room_height; yy += CELLSIZE) {
        if (tile_layer_find(-5, xx, yy)) {
            instance_create(xx, yy, o_solid);
        }
    }


// Number of surfaces to divide the room into,
// lengthways and widthways.
// The room should be evenly divisible by this.
// (Try just 1 first, to see if it works.)
surfaces_w = 1;
surfaces_h = 1;

// List of room's tile layers to flatten into a single layer.
// If some layers cannot be flattened, consider modifying
// this object so that multiple instances can be used.
var layers;
layers = ds_queue_create();
// Must be in descending order
ds_queue_enqueue(layers, 100);
ds_queue_enqueue(layers, -5);

// Assumes that the tiles in a room are in a regular grid,
// and tiles have a minimum size equal to the following:
var tilewidth;
tilewidth = CELLSIZE;
var tileheight;
tileheight = CELLSIZE;

surface_width = room_width / surfaces_w;
surface_height = room_height / surfaces_h;

var i, j;
// Create the surfaces
for (i = 0; i &lt; surfaces_w; i += 1) {
    for (j = 0; j &lt; surfaces_h; j += 1) {
        surf[i, j] = surface_create(surface_width, surface_height);
        surface_set_target(surf[i, j]);
        draw_clear_alpha(0, 0);
        surface_reset_target()
    }
}

var count;
count = 0;

do {
    // For each tile layer
    var layerdepth;
    layerdepth = ds_queue_dequeue(layers);
    // Copy all the tiles to the corresponding surface
    for (i = 0; i &lt; surfaces_w; i += 1) {
        for (j = 0; j &lt; surfaces_h; j += 1) {
            surface_set_target(surf[i, j]);
            // Since tile_layer_find() is the only way to access room tiles,
            // we must sweep over the entire room.
            for (xx = surface_width * i; xx &lt; (surface_width * (i + 1)); xx += tilewidth) {
                for (yy = surface_height * j; yy &lt; (surface_height * (j + 1)); yy += tileheight) {
                    var t;
                    t = tile_layer_find(layerdepth, xx, yy);
                    if (tile_exists(t)) {
                        var b;
                        b = tile_get_background(t);
                        var l;
                        l = tile_get_left(t);
                        var p;
                        p = tile_get_top(t);
                        var w;
                        w = tile_get_width(t);
                        var h;
                        h = tile_get_height(t);
                        draw_background_part(b, l, p, w, h, xx - (surface_width * i), yy - (surface_height * j));
                        tile_delete(t);
                        count += 1;
                    }
                }
            }
            surface_reset_target();
        }
    }
}
until ds_queue_empty(layers);

ds_queue_destroy(layers);
//show_message(string(count)+" tiles destroyed");

ini_open("text\mission1.ini");
kk = string(ini_read_real("Test", "Test", 6));
ini_close();
show_message("It works!!! " + kk);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, j;
for (i = 0; i &lt; surfaces_w; i += 1) {
    for (j = 0; j &lt; surfaces_h; j += 1) {
        surface_free(surf[i, j]);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i, j;

for (i = 0; i &lt; surfaces_w; i += 1) {
    for (j = 0; j &lt; surfaces_h; j += 1) {
        if (global.gamestate != STATE_GAME) {
            shader_set(shader_grayscale);
            draw_surface(surf[i, j], surface_width * i, surface_height * j);
            shader_reset();
        } else {
            draw_surface(surf[i, j], surface_width * i, surface_height * j);
        }
        draw_background(bg_statusbar2, 0, 480 -32)
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
